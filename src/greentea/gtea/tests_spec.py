#
# Copyright (c) 2021 Arm Limited and Contributors. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
"""Test Specification interface classes.

Defines the data to be generated by/from a build system to give enough information
to Greentea.
"""

import json
from .greentea_log import gt_logger


class TestBinary(object):
    """Class representing a Test Binary."""

    KW_BIN_TYPE = "binary_type"
    KW_BIN_PATH = "path"
    KW_COMP_LOG = "compare_log"

    BIN_TYPE_BOOTABLE = "bootable"
    BIN_TYPE_DEFAULT = BIN_TYPE_BOOTABLE
    SUPPORTED_BIN_TYPES = [BIN_TYPE_BOOTABLE]

    def __init__(self, path, binary_type, compare_log):
        """Initialise TestBinary.

        Args:
            path: Path to the binary in use.
            binary_type: Type of the binary.
            compare_log: Path of the compare log.
        """
        assert (
            binary_type in TestBinary.SUPPORTED_BIN_TYPES
        ), "Binary type %s not supported. Supported types [%s]" % (
            binary_type,
            ", ".join(TestBinary.SUPPORTED_BIN_TYPES),
        )
        self.__path = path
        self.__flash_method = binary_type
        self.__comp_log = compare_log

    def get_path(self):
        """Get binary path.

        Returns:
            Path to the binary.
        """
        return self.__path

    def get_compare_log(self):
        """Get compare log file.

        Returns:
            Path to the compare log.
        """
        return self.__comp_log


class Test(object):
    """Class representing a Test artifact that may contain more than one test binary."""

    KW_TEST_NAME = "name"
    KW_TEST_BINS = "binaries"

    def __init__(self, name, default_flash_method=None):
        """Initialise Test object.

        Args:
            name: Name of the test object.
            default_flash_method: Default method to use.
        """
        self.__name = name
        self.__default_flash_method = default_flash_method
        self.__binaries_by_flash_method = {}

    def get_name(self):
        """Get test name.

        Returns:
            Name of test.
        """
        return self.__name

    def get_binary(self, binary_type=TestBinary.BIN_TYPE_DEFAULT):
        """Get a test binary of specific flash type.

        Args:
            binary_type: Type of binary to return.

        Returns:
            Binary to flash if exists, or None.
        """
        return self.__binaries_by_flash_method.get(binary_type, None)

    def parse(self, test_json):
        """Parse json contents into object.

        Args:
            test_json: json data to parse into object.
        """
        assert Test.KW_TEST_BINS in test_json, "Test spec should contain key `binaries`"
        for binary in test_json[Test.KW_TEST_BINS]:
            mandatory_keys = [TestBinary.KW_BIN_PATH]
            assert set(mandatory_keys).issubset(
                set(binary.keys())
            ), "Binary spec should contain key [%s]" % ",".join(mandatory_keys)
            fm = binary.get(TestBinary.KW_BIN_TYPE, self.__default_flash_method)
            assert fm is not None, "Binary type not specified in build and binary spec."
            tb = TestBinary(
                binary[TestBinary.KW_BIN_PATH], fm, binary.get(TestBinary.KW_COMP_LOG)
            )
            self.__binaries_by_flash_method[fm] = tb

    def add_binary(self, path, binary_type, compare_log=None):
        """Add binary to the test.

        Args:
            path: Path to the binary.
            binary_type: Type of binary being added.
        """
        self.__binaries_by_flash_method[binary_type] = TestBinary(
            path, binary_type, compare_log
        )


class TestBuild(object):
    """Class for Test build."""

    KW_TEST_BUILD_NAME = "name"
    KW_PLATFORM = "platform"
    KW_TOOLCHAIN = "toolchain"
    KW_BAUD_RATE = "baud_rate"
    KW_BUILD_BASE_PATH = "base_path"
    KW_TESTS = "tests"
    KW_BIN_TYPE = "binary_type"

    def __init__(
        self, name, platform, toolchain, baud_rate, base_path, default_flash_method=None
    ):
        """Initialise TestBuild.

        Args:
            name: Name of the TestBuild.
            platform: Platform in use.
            toolchain: Toolchain in use.
            baud_rate: Baudrate for serial communication.
            base_path: Base path of the Tests.
            default_flash_method: Default flash method to use.
        """
        self.__name = name
        self.__platform = platform
        self.__toolchain = toolchain
        self.__baud_rate = baud_rate
        self.__base_path = base_path
        self.__default_flash_method = default_flash_method
        self.__tests = {}

    def get_name(self):
        """Get build name.

        Returns:
            Name of object.
        """
        return self.__name

    def get_platform(self):
        """Get platform name.

        Returns:
            Name of platform in use.
        """
        return self.__platform

    def get_toolchain(self):
        """Get toolchain.

        Returns:
            Toolchain in use.
        """
        return self.__toolchain

    def get_baudrate(self):
        """Get baud rate.

        Returns:
            Baudrate in use.
        """
        return self.__baud_rate

    def get_path(self):
        """Get path.

        Returns:
            Base path of the TestBuild.
        """
        return self.__base_path

    def get_tests(self):
        """Get tests dict.

        Returns:
            Dict representation of tests keyed by name.
        """
        return self.__tests

    def parse(self, build_spec):
        """Parse Test build json.

        Args:
            build_spec: json build spec to parse.
        """
        assert TestBuild.KW_TESTS in build_spec, (
            "Build spec should contain key '%s'" % TestBuild.KW_TESTS
        )
        for name, test_json in build_spec[TestBuild.KW_TESTS].items():
            test = Test(name, default_flash_method=self.__default_flash_method)
            test.parse(test_json)
            self.__tests[name] = test

    def add_test(self, name, test):
        """Add test.

        Args:
            name: Name of the test to add.
            test: Test object to add.
        """
        self.__tests[name] = test


class TestSpec(object):
    """Test specification. Contains Builds."""

    KW_BUILDS = "builds"
    test_spec_filename = "runtime_load"

    def __init__(self, test_spec_filename=None):
        """Initialise TestSpec.

        Args:
            test_spec_filename: Name of JSON TestSpec to load.
        """
        self.__target_test_spec = {}
        if test_spec_filename:
            self.test_spec_filename = test_spec_filename
            self.load(self.test_spec_filename)

    def load(self, test_spec_filename):
        """Load test spec directly from file.

        Args:
            test_spec_filename: Name of JSON file with TestSpec to load.

        Returns:
            True if load was successful.
        """
        try:
            with open(test_spec_filename, "r") as f:
                self.parse(json.load(f))
        except Exception as e:
            print("TestSpec::load('%s') %s" % (test_spec_filename, str(e)))
            return False

        self.test_spec_filename = test_spec_filename
        return True

    def parse(self, spec):
        """Parse test spec json.

        Args:
            spec: json test spec to parse.
        """
        assert TestSpec.KW_BUILDS, (
            "Test spec should contain key '%s'" % TestSpec.KW_BUILDS
        )
        for build_name, build in spec[TestSpec.KW_BUILDS].items():
            mandatory_keys = [
                TestBuild.KW_PLATFORM,
                TestBuild.KW_TOOLCHAIN,
                TestBuild.KW_BAUD_RATE,
                TestBuild.KW_BUILD_BASE_PATH,
            ]
            assert set(mandatory_keys).issubset(
                set(build.keys())
            ), "Build spec should contain keys [%s]. It has [%s]" % (
                ",".join(mandatory_keys),
                ",".join(build.keys()),
            )
            platform = build[TestBuild.KW_PLATFORM]
            toolchain = build[TestBuild.KW_TOOLCHAIN]

            # If there is no 'name' property in build, we will use build key
            # as build name
            name = build.get(TestBuild.KW_TEST_BUILD_NAME, build_name)

            tb = TestBuild(
                name,
                platform,
                toolchain,
                build[TestBuild.KW_BAUD_RATE],
                build[TestBuild.KW_BUILD_BASE_PATH],
                build.get(TestBuild.KW_BIN_TYPE, None),
            )
            tb.parse(build)
            self.__target_test_spec[name] = tb

    def get_test_builds(self, filter_by_names=None):
        """Get test builds.

        Args:
            filter_by_names: List of names of builds to filter.

        Returns:
            List of TestBuilds after filtering.
        """
        result = []
        if filter_by_names:
            assert type(filter_by_names) is list
            for tb in self.__target_test_spec.values():
                if tb.get_name() in filter_by_names:
                    result.append(tb)
        else:
            result = list(self.__target_test_spec.values())
        return result

    def get_test_build(self, build_name):
        """Get test build with given name.

        Args:
            build_name: Name of TestBuild to get.

        Returns:
            TestBuild if exists, else None.
        """
        return self.__target_test_spec.get(build_name, None)

    def add_test_builds(self, name, test_build):
        """Add test build.

        Args:
            name: Name of the test build.
            test_build: TestBuild object.
        """
        self.__target_test_spec[name] = test_build


def list_binaries_for_builds(test_spec, verbose_footer=False):
    """Parse test spec and list binaries (BOOTABLE) in lexicographical order.

    Args:
        test_spec: Test specification object.
        verbose_footer: Prints additional "how to use" Greentea footer.
    """
    test_builds = test_spec.get_test_builds()
    for tb in test_builds:
        gt_logger.gt_log(
            "available tests for build '%s', location '%s'"
            % (tb.get_name(), tb.get_path())
        )
        for tc in sorted(tb.get_tests().keys()):
            gt_logger.gt_log_tab("test '%s'" % tc)

    if verbose_footer:
        print(
            "\nExample: execute 'gt -t BUILD_NAME -n TEST_NAME' to run test "
            "TEST_NAME for build TARGET_NAME in current test specification"
        )
